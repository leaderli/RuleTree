options {
  STATIC = false;
  MULTI=true;
  VISITOR=true;
  VISITOR_DATA_TYPE="io.leaderli.rule.RuleContext";
  VISITOR_RETURN_TYPE="void";
  DEBUG_PARSER = true;
//  DEBUG_TOKEN_MANAGER = true;
//  DEBUG_LOOKAHEAD = true;
}
PARSER_BEGIN(RuleParser)
package io.leaderli.rule.tree;
import java.io.StringReader;
import io.leaderli.litool.core.exception.LiAssertUtil;
import io.leaderli.litool.core.meta.LiTuple;import io.leaderli.litool.core.text.StringUtils;
import io.leaderli.rule.RuleContext;

public class RuleParser{
    private RuleContext context;
    public void setRuleContext(RuleContext context) {
        this.context = context;
    }
    public static SimpleNode test(String expr) throws ParseException {
        RuleParser demo = new RuleParser(new StringReader(expr));
        return (SimpleNode) demo.test().jjtGetChild(0);
    }
    public static SimpleNode test(String expr,RuleContext context) throws ParseException {
        RuleParser demo = new RuleParser(new StringReader(expr));
        demo.context = context;
        return (SimpleNode) demo.test().jjtGetChild(0);
    }
 }
PARSER_END(RuleParser)

<DEFAULT>
SKIP : {
      " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}
TOKEN : {
      <TRUE:"true">
    | <FALSE:"false">
    | <AND:"AND"|"and">
    | <OR:"OR"|"or">
    | <NOT:"NOT"|"not">
    | <INT: "0"|(["1"-"9"] (["0"-"9"])*) >
    | <DOUBLE:<INT>( "." ["0"-"9"])+>
    | <PERCENT:(<DOUBLE>|<INT>)"%">
    | <TIME:["0"-"2"]["0"-"9"]":"["0"-"5"]["0"-"9"]":"["0"-"5"]["0"-"9"]>
    | <GT: ">" >
    | <LT: "<" >
    | <LE: "<=" >
    | <GE: ">=" >
    | <EQ: "=" >
    | <NE: "!=" >
    | <PLUS: "+" >
    | <MINUS: "-" >
    | <LPAREN: "(" >
    | <RPAREN: ")" >
    | <SEMICOLON: ";">
    | <IDENTIFIER: (["a"-"z"]|["A"-"Z"]|"_")(["a"-"z"]|["A"-"Z"]|["0"-"9"]|"_")*>
}


SimpleNode Start() :{}{
    (rule()) +<EOF>{
        return jjtThis;
    }
}
void rule():{Token t;}{
    "rule:"
    t=<INT> { jjtThis.jjtSetValue(Integer.parseInt(t.image));}
    expr()
}
void expr()#void:{}{
    term() (
         <AND>#and term()
       | <OR>#or term()
    )*
}

void term():{}{
         <TRUE>{jjtThis.jjtSetValue(true);}
       | <FALSE>{jjtThis.jjtSetValue(false);}
       | <NOT> term() #neg
       | <LPAREN> expr() <RPAREN> {jjtThis.jjtSetValue("()");}
       | compare()
}

void num() :{Token t;}{
    (t=<INT> |t=<DOUBLE> |t=<PERCENT> |t=<TIME> ){
       String value = t.image;
       switch (t.kind){
            case INT:
                jjtThis.jjtSetValue(LiTuple.of("INT",Integer.parseInt(value)));
                break;
            case DOUBLE:
                jjtThis.jjtSetValue(LiTuple.of("DOUBLE",Double.parseDouble(value)));
                break;
            case PERCENT:
                jjtThis.jjtSetValue(LiTuple.of("PERCENT",Double.parseDouble(value.replace("%","")) / 100));
                break;
            case TIME:
                jjtThis.jjtSetValue(LiTuple.of("TIME",value));
                break;
            default:
                throw new ParseException("unsupported token " + tokenImage[t.kind] );
       }
    }
}

void compare() :{Token name;String type;}{
    var(){}(math() (num() |var()))?operator() num()
    {
        // 校验所有元素类型是否匹配
        System.out.println(jjtThis.children);

    }
}

void math():{Token t;}{
    (t=<PLUS> |t=<MINUS> ){ jjtThis.jjtSetValue(t.image);}
}


void operator() :{Token t;}{
    (t=<EQ>|t=<NE>|t=<GT>|t=<GE>|t=<LT>|t=<LE>){ jjtThis.jjtSetValue(t.image);}
}

void var() :{Token t;}{
    t=<IDENTIFIER>{jjtThis.jjtSetValue(LiTuple.of(context.getType(t.image),t.image));}
}

// test

SimpleNode test() :{}{
    (
         num()
        | LOOKAHEAD(2)expr()
        | var()
    )
    <EOF>
    {
        return jjtThis;
    }
}

